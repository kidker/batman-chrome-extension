// Generated by CoffeeScript 1.6.3
var app, _ref,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

window.BatmanDebug = (function() {
  function BatmanDebug() {}

  BatmanDebug.objectMap = new Batman.Hash;

  BatmanDebug.observerMap = new Batman.Hash;

  BatmanDebug.prototype.init = function() {
    this.setUpCounters();
    return this.messageListener();
  };

  BatmanDebug.prototype.messageListener = function() {
    var _this = this;
    return window.addEventListener('message', function(event) {
      if (event.data["for"] === 'batman.debug') {
        return _this.handleMessage(event.data.data, function(res, options) {
          var data;
          if (options == null) {
            options = {};
          }
          data = JSON.stringify(BatmanDebug.prettify(res));
          return window.postMessage({
            id: event.data.id,
            "for": 'batbelt',
            data: data,
            options: options
          }, '*');
        });
      }
    });
  };

  BatmanDebug.prototype.setUpCounters = function() {
    this.counters = {
      bindings: 0,
      events: 0,
      observers: 0
    };
    this.originalPropertyObserve = Batman.Property.prototype.observe;
    Batman.DOM.AbstractBinding.prototype.constructor = this.wrapWithCounter('bindings', Batman.DOM.AbstractBinding.prototype.constructor);
    Batman.Event.prototype.fireWithContext = this.wrapWithCounter('events', Batman.Event.prototype.fireWithContext);
    return Batman.Property.prototype.observe = this.wrapWithCounter('observers', Batman.Property.prototype.observe);
  };

  BatmanDebug.prototype.handleMessage = function(msg, cb) {
    switch (msg.type) {
      case 'ping':
        return cb({
          type: 'pong'
        });
      case 'storageAdapter':
        return this.storageAdapter(msg.key, msg.options, cb);
      case 'observeLoadedProperty':
        return this.observeLoadedProperty(msg.id, msg.property, cb);
      case 'startObservingEvents':
        return this.startObservingEvents(msg.keypath, cb);
      case 'stopObservingEvents':
        return this.stopObservingEvents(msg.keypath, cb);
      case 'stats':
        return this.fetchCounters(cb);
      default:
        return console.log('Unknown message', msg);
    }
  };

  BatmanDebug.prototype.storageAdapter = function(key, options, cb) {
    var action, modelName, _ref;
    _ref = key.split('::'), action = _ref[0], modelName = _ref[1];
    modelName = Batman.helpers.camelize(modelName);
    return BatmanDebug[modelName][action](options, function(res) {
      return cb(res, {
        close: true
      });
    });
  };

  BatmanDebug.prototype.observeLoadedProperty = function(id, property, cb) {
    var wrappedObserve, _ref;
    wrappedObserve = Batman.Property.prototype.observe;
    Batman.Property.prototype.observe = this.originalPropertyObserve;
    if ((_ref = BatmanDebug.objectMap.get(id)) != null) {
      _ref.observe(property, function(newValue) {
        return cb(newValue, {
          close: false
        });
      });
    }
    return Batman.Property.prototype.observe = wrappedObserve;
  };

  BatmanDebug.prototype.wrapFire = function(emitter, cb) {
    if (!emitter.debug_fire) {
      emitter.debug_fire = emitter.fire;
    }
    return emitter.fire = function() {
      var args, eventForKey, key, _ref;
      key = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      eventForKey = this.event(key, false);
      if (eventForKey) {
        cb({
          key: key,
          prevented: eventForKey.isPrevented(),
          listeners: (_ref = eventForKey.handlers) != null ? _ref.length : void 0
        });
      } else {
        cb({
          key: key,
          prevented: null,
          listeners: 0
        });
      }
      return this.debug_fire.apply(this, arguments);
    };
  };

  BatmanDebug.prototype.unWrapFire = function(emitter) {
    if (emitter && emitter.debug_fire) {
      emitter.fire = emitter.debug_fire;
      return delete emitter.debug_fire;
    }
  };

  BatmanDebug.prototype.startObservingEvents = function(keypath, cb) {
    var property, value;
    this.stopObservingEvents(keypath);
    property = Batman.currentApp.property(keypath);
    if (!property) {
      cb({
        keypath: keypath,
        error: 'Keypath does not exist'
      });
      return;
    }
    BatmanDebug.observerMap.set(keypath, property);
    this.wrapFire(property, cb);
    value = property.getValue();
    if (!value) {
      cb({
        keypath: keypath,
        error: 'Keypath not set'
      });
      return;
    }
    return this.wrapFire(value, cb);
  };

  BatmanDebug.prototype.stopObservingEvents = function(keypath, cb) {
    var oldProperty;
    oldProperty = BatmanDebug.observerMap.get(keypath);
    if (oldProperty) {
      this.unWrapFire(oldProperty);
      return this.unWrapFire(oldProperty.getValue());
    }
  };

  BatmanDebug.prototype.fetchCounters = function(cb) {
    return cb(this.counters, {
      close: true
    });
  };

  BatmanDebug.prototype.wrapWithCounter = function(name, fn) {
    var self;
    self = this;
    return function() {
      self.counters[name]++;
      return fn.apply(this, arguments);
    };
  };

  return BatmanDebug;

})();

BatmanDebug.AppController = (function() {
  function AppController(name) {
    var instanceName,
      _this = this;
    this.name = name;
    instanceName = this.name.substr(0, this.name.length - 'Controller'.length);
    this.instanceName = Batman.helpers.underscore(instanceName);
    this.instance = Batman.currentApp.get("controllers." + instanceName);
    BatmanDebug.objectMap.set(this.instance._batmanID(), this.instance);
    this.instance.accessor('_isCurrentController', function() {
      return Batman.currentApp.get('currentRoute.controller') === _this.instanceName;
    });
  }

  AppController.prototype.toJSON = function() {
    var obj;
    obj = BatmanDebug.prettify(this.instance);
    obj.id = this.instance._batmanID();
    obj.name = this.name;
    obj.action = this.instance.get('action');
    obj.path = this.instance.get('params.path');
    obj._isCurrentController = this.instance.get('_isCurrentController');
    return obj;
  };

  AppController.readAll = function(options, cb) {
    var attr, controller, controllers, name, _ref;
    controllers = [];
    _ref = Batman.currentApp;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      attr = _ref[name];
      if (attr.prototype instanceof Batman.Controller) {
        controller = new this(name);
        controllers.push(controller.toJSON());
      }
    }
    return cb(controllers);
  };

  return AppController;

})();

BatmanDebug.AppModel = (function() {
  function AppModel(name) {
    this.name = name;
    this.instances = Batman.currentApp[this.name].get('loaded');
    this.instances.forEach(function(instance) {
      return BatmanDebug.objectMap.set(instance._batmanID(), instance);
    });
  }

  AppModel.prototype.serializeInstances = function() {
    return this.instances.map(function(model) {
      return {
        id: model._batmanID(),
        properties: model.toJSON()
      };
    });
  };

  AppModel.prototype.toJSON = function() {
    return {
      name: this.name,
      instances: this.serializeInstances()
    };
  };

  AppModel.readAll = function(options, cb) {
    var attr, model, models, name, _ref;
    models = [];
    _ref = Batman.currentApp;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      attr = _ref[name];
      if (attr.prototype instanceof Batman.Model) {
        model = new this(name);
        if (model.instances.length) {
          models.push(model.toJSON());
        }
      }
    }
    return cb(models);
  };

  return AppModel;

})();

BatmanDebug.AppView = (function() {
  function AppView() {}

  AppView.readAll = function(options, cb) {
    var attr, name, views, _ref;
    views = [];
    _ref = Batman.currentApp;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      attr = _ref[name];
      if (attr.prototype instanceof Batman.Model) {
        views.push({
          name: name
        });
      }
    }
    return cb(views);
  };

  return AppView;

})();

if ((app = (_ref = window.Batman) != null ? _ref.currentApp : void 0) && (app.debug == null)) {
  app.debug = new BatmanDebug();
  app.debug.init();
}
